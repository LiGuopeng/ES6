<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    /*解构不仅可以用于数组，还可以用于对象。
    let { foo, bar } = { foo: "aaa", bar: "bbb" };
    console.log(foo,bar)//aaa  bbb
    //相当于
    //{a,b}==={a:a,b:b}


    /*对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；
    而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
    let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
    baz // "aaa"

    let obj = { first: 'hello', last: 'world' };
    let { first: f, last: l } = obj;
    f // 'hello'
    l // 'world'*/



    /*
    * 与数组一样，解构也可以用于嵌套结构的对象。
    let obj = {
        p: [
            'Hello',
            { y: 'World' }
        ]
    };
    let { p: [x, { y }] } = obj;
    x // "Hello"
    y // "World"
    //注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。
    let obj = {
        p: [
            'Hello',
            { y: 'World' }
        ]
    };

    let { p, p: [x, { y }] } = obj;
    x // "Hello"
    y // "World"
    p // ["Hello", {y: "World"}]*/


    /*下面是嵌套赋值的例子。
   let obj = {};
    let arr = [];

    ({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });

    obj // {prop:123}
    arr // [true]*/





/*
    // 报错
    let {foo: {bar}} = {baz: 'baz'};
    //上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单
    //，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。
        let _tmp = {baz: 'baz'};
       _tmp.foo.bar // 报错      */


    /*如果要将一个已经声明的变量用于解构赋值，必须非常小心
    // 错误的写法
    let x;
    {x} = {x: 1};
    // SyntaxError: syntax error
    上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，
    从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。
    // 正确的写法
    let x;
    ({x} = {x: 1});   */


    /* //数组和对象之间的解构
    //是按照数组的索引值解构的
    let arr = [1, 2, 3];
    let {0 : first, [arr.length - 1] : last} = arr;
    first // 1
    last // 3*/



</script>
</body>
</html>